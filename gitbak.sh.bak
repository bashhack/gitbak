#!/bin/bash

# GitBak - Automatic Commit Safety Net for Pair Programming
# 
# This script automatically commits changes to git at regular intervals,
# providing a safety net for pair programming sessions or long coding sessions.
#
# Usage:
#   - Run from inside a Git repository: ./gitbak.sh
#   - Press Ctrl+C to stop and view the session summary
#
# Configuration (via environment variables):
#   - INTERVAL_MINUTES: Minutes between commits (default: 5)
#   - BRANCH_NAME: Custom branch name (default: gitbak-{timestamp})
#   - COMMIT_PREFIX: Custom commit message prefix (default: "[GitBak] Automatic checkpoint")
#   - CREATE_BRANCH: Whether to create a new branch (default: "true")
#   - VERBOSE: Show/hide informational messages (default: "true")
#   - SHOW_NO_CHANGES: Show messages when no changes detected (default: "false")
#   - REPO_PATH: Path to repository (default: current directory)
#   - CONTINUE_SESSION: Continue from existing branch (default: "false")

# Don't use set -e as it can interfere with error handling and cleanup

# Optional debug logging (set DEBUG=true to enable)
DEBUG=${DEBUG:-"false"}
LOG_FILE=${LOG_FILE:-"$(pwd)/.gitbak.log"}  # Default log in current directory

# Initialize logging if debug is enabled
if [ "$DEBUG" = "true" ]; then
    echo "üîç Debug logging enabled. Logs will be written to: $LOG_FILE"
    # Create log directory if needed
    LOG_DIR=$(dirname "$LOG_FILE")
    [ "$LOG_DIR" != "." ] && mkdir -p "$LOG_DIR" 2>/dev/null || true
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] GitBak debug logging started" > "$LOG_FILE"
fi

log() {
    # Skip if debug is not enabled
    [ "$DEBUG" != "true" ] && return 0
    
    local level="$1"
    shift
    local msg="$(date '+%Y-%m-%d %H:%M:%S') [$level] $*"
    
    # Always echo errors to console, warnings if verbose
    if [ "$level" = "ERROR" ] || ([ "$VERBOSE" = "true" ] && [ "$level" = "WARNING" ]); then
        echo "$msg"
    fi
    
    # Write to log file
    echo "$msg" >> "$LOG_FILE"
}

# Check for required commands
check_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        echo "‚ùå Error: Required command '$1' not found. Please install it and try again."
        exit 1
    fi
}

# Verify essential dependencies
check_command git
check_command grep
check_command sed
check_command shasum || check_command md5sum || { echo "‚ùå Error: Neither shasum nor md5sum found"; exit 1; }

# Use environment variables if set, otherwise use defaults
REPO_PATH=${REPO_PATH:-$(pwd)}

# Validate interval is a positive number
INTERVAL_MINUTES=${INTERVAL_MINUTES:-5}
# POSIX-compliant number validation (avoids Bash-specific [[/=~ constructs)
if ! echo "$INTERVAL_MINUTES" | grep -q '^[0-9][0-9]*$' || [ "$INTERVAL_MINUTES" -lt 1 ]; then
    echo "‚ö†Ô∏è  Warning: Invalid INTERVAL_MINUTES '$INTERVAL_MINUTES'. Using default of 5 minutes."
    log "WARNING" "Invalid INTERVAL_MINUTES '$INTERVAL_MINUTES', using default of 5 minutes"
    INTERVAL_MINUTES=5
fi$' || [ "$INTERVAL_MINUTES" -lt 1 ]; then
    echo "‚ö†Ô∏è  Warning: Invalid INTERVAL_MINUTES '$INTERVAL_MINUTES'. Using default of 5 minutes."
    log "WARNING" "Invalid INTERVAL_MINUTES '$INTERVAL_MINUTES', using default of 5 minutes"
    INTERVAL_MINUTES=5
fi

BRANCH_NAME=${BRANCH_NAME:-"gitbak-$(date +%Y%m%d-%H%M%S)"}
COMMIT_PREFIX=${COMMIT_PREFIX:-"[GitBak] Automatic checkpoint"}
CREATE_BRANCH=${CREATE_BRANCH:-"true"}
VERBOSE=${VERBOSE:-"true"}  # Show/hide informational messages
SHOW_NO_CHANGES=${SHOW_NO_CHANGES:-"false"}  # Show messages when no changes detected
CONTINUE_SESSION=${CONTINUE_SESSION:-"false"}  # Continue an existing GitBak session

# Track script exit code
EXIT_CODE=0

# Initialize counters and stats
COMMITS_MADE=0
COUNTER=1  # Default starting counter
START_TIME=$(date +%s)
ORIGINAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
log "INFO" "Starting GitBak on branch: $ORIGINAL_BRANCH"

# Function to display summary and clean up on exit
cleanup() {
  # Remove the lock file (if we own it)
  if [ -f "$LOCK_FILE" ] && [ "$(cat "$LOCK_FILE" 2>/dev/null)" = "$$" ]; then
    log "INFO" "Cleaning up lock file for PID $$"
    rm -f "$LOCK_FILE"
  fi

  END_TIME=$(date +%s)
  DURATION=$((END_TIME - START_TIME))
  
  # Format duration as HH:MM:SS (POSIX-compliant)
  HOURS=`expr $DURATION / 3600`
  MINUTES=`expr \( $DURATION % 3600 \) / 60`
  SECONDS=`expr $DURATION % 60`
  
  echo ""
  echo "---------------------------------------------"
  echo "üìä GitBak Session Summary"
  echo "---------------------------------------------"
  echo "‚úÖ Total commits made: $COMMITS_MADE"
  echo "‚è±Ô∏è  Session duration: ${HOURS}h ${MINUTES}m ${SECONDS}s"
  if [ "$CREATE_BRANCH" = "true" ]; then
    echo "üåø Working branch: $BRANCH_NAME"
    echo ""
    echo "To merge these changes to your original branch:"
    echo "  git checkout $ORIGINAL_BRANCH"
    echo "  git merge $BRANCH_NAME"
    echo ""
    echo "To squash all commits into one:"
    echo "  git checkout $ORIGINAL_BRANCH"
    echo "  git merge --squash $BRANCH_NAME"
    echo "  git commit -m \"Merged GitBak session\""
  else
    echo "üåø Working branch: $ORIGINAL_BRANCH (unchanged)"
  fi
  
  # Show branch visualization if 'git log' is available
  if command -v git log > /dev/null; then
    echo ""
    echo "üîç Branch visualization (last 10 commits):"
    echo "---------------------------------------------"
    # Try to use a more colorful format if possible
    if git log --graph --oneline --decorate --all --color=always -n 10 > /dev/null 2>&1; then
      git log --graph --oneline --decorate --all --color=always -n 10
    else
      # Fallback to simpler format
      git log --graph --oneline --decorate -n 10
    fi
  fi
  
  echo "---------------------------------------------"
  echo "üõë GitBak terminated at $(date)"
  # Exit with the last error code or 0 if successful
  exit ${EXIT_CODE:-0}
}

# Set up trap for Ctrl+C and other signals (including HUP for terminal disconnects)
trap cleanup INT TERM EXIT HUP

# Check if we're in a git repository
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "‚ùå Error: Not a git repository. Please run this script from a git repository."
    log "ERROR" "Not in a git repository"
    exit 1
fi
log "INFO" "Git repository verified"

# Check for existing lock file to prevent multiple instances
# Use shasum (widely available) to handle path with special characters
REPO_HASH=$(echo "$REPO_PATH" | shasum | cut -d' ' -f1)
LOCK_FILE="/tmp/gitbak-$REPO_HASH.lock"

# Portable lock file mechanism with race condition mitigation
TEMP_LOCK_FILE="${LOCK_FILE}.$$"

# Write PID to a temporary file first
echo $$ > "$TEMP_LOCK_FILE"

# Attempt to create a hard link to the real lock file, which is atomic
if ln "$TEMP_LOCK_FILE" "$LOCK_FILE" 2>/dev/null; then
    # We got the lock
    rm -f "$TEMP_LOCK_FILE"
else
    # Lock file exists, check if process is still running
    rm -f "$TEMP_LOCK_FILE"
    PID=$(cat "$LOCK_FILE" 2>/dev/null || echo "unknown")
    
    if ps -p "$PID" >/dev/null 2>&1; then
        echo "‚ùå Error: Another GitBak instance is already running for this repository (PID: $PID)"
        log "ERROR" "Another GitBak instance is already running (PID: $PID)"
        exit 1
    else
        echo "‚ö†Ô∏è  Warning: Found stale lock file. Removing it."
        log "WARNING" "Found stale lock file for PID $PID. Removing it."
        rm -f "$LOCK_FILE"
        
        # Create a new temporary lock file
        TEMP_LOCK_FILE="${LOCK_FILE}.$$"
        echo $$ > "$TEMP_LOCK_FILE"
        
        # Try again to create the lock atomically
        if ln "$TEMP_LOCK_FILE" "$LOCK_FILE" 2>/dev/null; then
            rm -f "$TEMP_LOCK_FILE"
            log "INFO" "Successfully acquired lock after removing stale lock"
        else
            echo "‚ùå Error: Failed to acquire lock even after removing stale lock"
            log "ERROR" "Failed to acquire lock after removing stale lock"
            rm -f "$TEMP_LOCK_FILE"
            exit 1
        fi
    fi
fi

# If we get here, we have the lock

# Figure out the branch to use
CURRENT_BRANCH=$(git branch --show-current)

# Handle continuing or creating a session
if [ "$CONTINUE_SESSION" = "true" ]; then
    # Using the existing branch, no need to create a new one
    CREATE_BRANCH="false"
    echo "üîÑ Continuing GitBak session on branch: $CURRENT_BRANCH"
    
    # More robust commit number detection - escapes commit prefix for grep
    ESCAPED_PREFIX=$(echo "$COMMIT_PREFIX" | sed 's/[][\\/.*^$]/\\&/g')
    
    # Store failure state of each step in the pipeline
    set -o pipefail 2>/dev/null || log "WARNING" "pipefail not supported in this shell"
    
    # Get the highest commit number from any format
    git log --pretty=format:"%s" > /tmp/gitbak-log.$$ 2>/dev/null
    GIT_LOG_EXIT_CODE=$?
    if [ $GIT_LOG_EXIT_CODE -ne 0 ]; then
        log "WARNING" "Failed to get git log history: exit code $GIT_LOG_EXIT_CODE"
        HIGHEST_NUM=0
    else
        HIGHEST_NUM=$(grep -E "$ESCAPED_PREFIX #[0-9]+" /tmp/gitbak-log.$$ | head -1 | grep -o "#[0-9]\+" | grep -o "[0-9]\+" || echo "0")
        log "INFO" "Detected highest commit number: $HIGHEST_NUM"
        rm -f /tmp/gitbak-log.$$
    fi
    
    # Disable pipefail to avoid affecting the rest of the script
    set +o pipefail 2>/dev/null
    
    if [ -n "$HIGHEST_NUM" ] && [ "$HIGHEST_NUM" != "0" ]; then
        # Start from the next commit number
        COUNTER=$((HIGHEST_NUM + 1))
        echo "‚ÑπÔ∏è  Found previous commits - starting from commit #$COUNTER"
    else
        echo "‚ÑπÔ∏è  No previous commits found with prefix '$COMMIT_PREFIX' - starting from commit #1"
    fi
elif [ "$CREATE_BRANCH" = "true" ]; then
    # Check if there are uncommitted changes
    if [ -n "$(git status --porcelain)" ]; then
        echo "‚ö†Ô∏è  Warning: You have uncommitted changes."
        echo "Would you like to commit them before creating the GitBak branch? (y/n)"
        read -r answer
        if [ "$answer" = "y" ] || [ "$answer" = "Y" ]; then
            git add .
            if ! git commit -m "Manual commit before starting GitBak session"; then
                echo "‚ùå Error: Failed to create initial commit. Please fix any git issues and try again."
                rm -f "$LOCK_FILE"
                exit 1
            fi
            echo "‚úÖ Created initial commit"
        fi
    fi
    
    # Check if branch already exists
    if git show-ref --verify --quiet refs/heads/"$BRANCH_NAME"; then
        echo "‚ö†Ô∏è  Warning: Branch '$BRANCH_NAME' already exists."
        echo "Would you like to use a different branch name? (y/n)"
        read -r answer
        if [ "$answer" = "y" ] || [ "$answer" = "Y" ]; then
            BRANCH_NAME="$BRANCH_NAME-$(date +%H%M%S)"
            echo "üåø Using new branch name: $BRANCH_NAME"
        fi
    fi
    
    # Create and checkout new branch
    if ! git checkout -b "$BRANCH_NAME"; then
        echo "‚ùå Error: Failed to create new branch. Please check your git configuration."
        rm -f "$LOCK_FILE"
        exit 1
    fi
    echo "üåø Created and switched to new branch: $BRANCH_NAME"
else
    echo "üåø Using current branch: $CURRENT_BRANCH"
fi

echo "üîÑ GitBak started at $(date)"
echo "üìÇ Repository: $REPO_PATH"
echo "‚è±Ô∏è  Interval: $INTERVAL_MINUTES minutes"
echo "üìù Commit prefix: $COMMIT_PREFIX"
echo "üîä Verbose mode: $VERBOSE"
echo "üîî Show no-changes messages: $SHOW_NO_CHANGES"
echo "‚ùì Press Ctrl+C to stop and view session summary"

# Counter for commit numbering
COUNTER=1

while true; do
    # Check if there are changes (capture the exit code)
    GIT_STATUS_OUTPUT=$(git status --porcelain 2>&1)
    GIT_STATUS_EXIT_CODE=$?
    if [ $GIT_STATUS_EXIT_CODE -ne 0 ]; then
        echo "‚ùå Error: Failed to check git status: $GIT_STATUS_OUTPUT"
        log "ERROR" "git status failed with exit code $GIT_STATUS_EXIT_CODE: $GIT_STATUS_OUTPUT"
        echo "Will retry in $INTERVAL_MINUTES minutes."
        sleep $((INTERVAL_MINUTES * 60))
        continue
    fi
    
    if [ -n "$GIT_STATUS_OUTPUT" ]; then
        # There are changes to commit
        TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")
        
        # Try to add and commit changes
        GIT_ADD_OUTPUT=$(git add . 2>&1)
        GIT_ADD_EXIT_CODE=$?
        if [ $GIT_ADD_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è  Warning: Failed to stage changes: $GIT_ADD_OUTPUT"
            log "WARNING" "git add failed with exit code $GIT_ADD_EXIT_CODE: $GIT_ADD_OUTPUT"
            echo "Will retry next interval."
            sleep $((INTERVAL_MINUTES * 60))
            continue
        fi
        
        # Create a secure temporary file
        COMMIT_OUTPUT="/tmp/gitbak-commit-output.$$"
        
        # Try to commit the changes
        git commit -m "$COMMIT_PREFIX #$COUNTER - $TIMESTAMP" 2>&1 | tee "$COMMIT_OUTPUT"
        # PIPESTATUS is bash-specific, use a POSIX-compliant alternative
        GIT_COMMIT_EXIT_CODE=$?
        if [ $GIT_COMMIT_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Commit #$COUNTER created at $TIMESTAMP"
            log "INFO" "Successfully created commit #$COUNTER"
            # POSIX-compliant arithmetic
            COUNTER=`expr $COUNTER + 1`
            COMMITS_MADE=`expr $COMMITS_MADE + 1`
        else
            echo "‚ö†Ô∏è  Warning: Failed to create commit:"
            cat "$COMMIT_OUTPUT"
            log "WARNING" "git commit failed with exit code $GIT_COMMIT_EXIT_CODE: $(cat "$COMMIT_OUTPUT" 2>/dev/null || echo "unknown error")"
            echo "Will retry next interval."
        fi
        rm -f "$COMMIT_OUTPUT"
    elif [ "$SHOW_NO_CHANGES" = "true" ] && [ "$VERBOSE" = "true" ]; then
        echo "‚ÑπÔ∏è  No changes to commit at $(date +"%H:%M:%S")"
        log "INFO" "No changes to commit detected"
    fi
    
    # Wait for the next interval
    sleep $((INTERVAL_MINUTES * 60))
done
# This marks the end of the script